

# This file was *autogenerated* from the file differential.sage
from sage.all_cmdline import *   # import sage library

_sage_const_16 = Integer(16); _sage_const_12 = Integer(12); _sage_const_125 = Integer(125); _sage_const_96 = Integer(96); _sage_const_8 = Integer(8); _sage_const_7 = Integer(7); _sage_const_1 = Integer(1); _sage_const_100 = Integer(100); _sage_const_0 = Integer(0); _sage_const_0p5 = RealNumber('0.5'); _sage_const_0p05 = RealNumber('0.05'); _sage_const_0p1 = RealNumber('0.1')# Differential Cryptanalysis for GrainSoft128AEAD
from sage.all import *
from GrainSoft_v2 import GrainSoft128AEAD
import os
import time
import numpy as np

print("Starting differential cryptanalysis...")

# Timing: Start
start_time = time.time()

# Generate key and base IV
key = os.urandom(_sage_const_16 )  # 128-bit key
iv = os.urandom(_sage_const_12 )   # 96-bit IV
print(f"Using key: {key.hex()}")
print(f"Base IV: {iv.hex()}")

# Parameters
keystream_length = _sage_const_125   # 125 bytes = 1000 bits
iv_bits = _sage_const_96   # IV size
positions_to_test = range(iv_bits)  # i.e., 0 to 95
 # Test first 12 IV bits (adjust for speed)
results = []

# Helper: Convert bytes to bits
def bytes_to_bits(data):
    bits = []
    for byte in data:
        for i in range(_sage_const_8 ):
            bits.append((byte >> (_sage_const_7  - i)) & _sage_const_1 )
    return bits

# Differential analysis for each IV bit flip
for pos in positions_to_test:
    print(f"\nTesting IV bit position {pos}...")
    bit_start = time.time()
    
    # Create modified IV
    iv2 = bytearray(iv)
    # Flip one bit in the IV safely
    byte_idx = pos // _sage_const_8 
    bit_idx = _sage_const_7  - (pos % _sage_const_8 )
    iv2[byte_idx] ^= (_sage_const_1  << bit_idx)

    
    # Initialize ciphers
    try:
        cipher1 = GrainSoft128AEAD(key, iv)
        cipher2 = GrainSoft128AEAD(key, bytes(iv2))
    except Exception as e:
        print(f"Error initializing ciphers: {e}")
        continue
    
    # Generate keystreams
    ks1 = cipher1._generate_keystream(keystream_length)
    ks2 = cipher2._generate_keystream(keystream_length)
    
    # Convert to bits
    bits1 = bytes_to_bits(ks1)
    bits2 = bytes_to_bits(ks2)
    
    # Compute difference
    diff = [a ^ b for a, b in zip(bits1, bits2)]
    hamming_weight = sum(diff)
    hamming_ratio = hamming_weight / len(diff)
    
    # Analyze early bits (first 100)
    early_diff = diff[:_sage_const_100 ]
    early_hamming = sum(early_diff)
    early_ratio = early_hamming / len(early_diff) if early_diff else _sage_const_0 
    
    results.append({
        'position': pos,
        'hamming_weight': hamming_weight,
        'total_bits': len(diff),
        'hamming_ratio': hamming_ratio,
        'early_hamming': early_hamming,
        'early_ratio': early_ratio
    })
    
    print(f"Hamming weight: {hamming_weight}/{len(diff)} ({float(hamming_ratio):.2%})")
    print(f"Early (100 bits) hamming: {early_hamming}/100 ({float(early_ratio):.2%})")
    print(f"Time for position {pos}: {time.time() - bit_start:.2f} seconds")

# Summarize results
print("\n=== Summary ===")
mean_ratio = np.mean([r['hamming_ratio'] for r in results])
std_ratio = np.std([r['hamming_ratio'] for r in results])
mean_early = np.mean([r['early_ratio'] for r in results])
print(f"Mean Hamming ratio: {float(mean_ratio):.2%} Â± {float(std_ratio):.2%}")
print(f"Mean Early Hamming ratio: {float(mean_early):.2%}")
print(f"Total Time: {time.time() - float(start_time):.2f} seconds")

# Evaluate security
if abs(mean_ratio - _sage_const_0p5 ) > _sage_const_0p05  or abs(mean_early - _sage_const_0p5 ) > _sage_const_0p1 :
    print("Warning: Significant bias detected. Cipher may be vulnerable to differential attacks.")
else:
    print("Good: Hamming weights are close to 50%, suggesting strong diffusion.")

